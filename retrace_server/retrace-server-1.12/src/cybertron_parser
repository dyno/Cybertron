#!/usr/bin/python
import sys
import re
sys.path.insert(0, "/usr/share/retrace-server/")
from retrace import *
from plugins import *
import json

############################################################################
### Use Factory Method Design Mode
###         Parser              Searcher
###            ^                   ^
###            |                   |  
###     ConcreteParser  <-  ConcreteSeacher
############################################################################

class Parser:
    """ Abstract base class Parser """

    def __init__(self, task):
        if self.__class__ == Parser:
            raise NotImplementedError, \
                "Cannot create object of abstract class Parser"
        self.task = task

    def parse(self):
        """ Abstract method, derived class must overide """
        raise NotImplementedError, \
            "Cannot call abstract method"

    def get_search_dsl(self, query_field):
        """ Abstract method, derived class must overide """
        raise NotImplementedError, \
            "Cannot call abstract method"

class CrashParser(Parser):

    def __init__(self, task):
        Parser.__init__(self, task)
    
        if task.has_backtrace() == False:
            raise RuntimeError, "No backtrace"
            
        self.lines = task.get_backtrace().split('\n')
        self.crash_ip = None
        self.call_trace = []
    
    def parse(self):
        is_crash_ip_found = False
        for line in self.lines:
            if is_crash_ip_found == False:
                self.crash_ip = self.parse_crash_ip(line)
                if self.crash_ip != None:
                    is_crash_ip_found = True
            elif len(self.call_trace) < 3: 
                name = self.parse_call_trace(line)
                if name != None:
                    self.call_trace.append(name)
            else:
                break
        log_info("crash_ip: %s" %(self.crash_ip)) 
        log_info("call_trace: %s" %(self.call_trace)) 
        return is_crash_ip_found
  
    def get_search_dsl(self, query_field): 
        query = self.crash_ip
        for i in self.call_trace:
            query += " " + i
        fields = "[\"" + "\",\"".join(query_field) +"\"]"

        dsl = '{"query":{"multi_match":{"query":"%s", "fields":%s}}}' %(query, fields)
        log_info("query dsl: %s" %(dsl))
        return dsl    

    def parse_crash_ip(self, line):
        #FIXME: add 32bit support
        pattern = "(RIP:) ([0-9a-f]{4}:\[\<[0-9a-f]{16}\>\])  "\
                        "(\[\<[0-9a-f]{16}\>\]) (?P<function_name>.+)\+"
        prog = re.compile(pattern)
        result =  prog.match(line)
        if result != None:
            return result.group('function_name')   
        return None

    def parse_call_trace(self, line):
        pattern = " (\[\<[a-f0-9]{16}\>\]) (?P<function_name>.+)\+"
        prog = re.compile(pattern)
        result = prog.match(line)
        if result != None:
            return result.group('function_name')   
        return None

class Searcher:
    """ Abstract base class Searcher """
    def __init__(self, es_url, query_field, task):
        if self.__class__ == Searcher:
            raise NotImplementedError, \
                "Cannot create object of abstract class Parser"
        self.es_url = es_url
        self.query_field = query_field
        self.task = task

    def create_parser(self):
        """ Abstract method, derived class must overide """
        raise NotImplementedError, \
            "Cannot call abstract method"

    def get_search_result(self):
        parser = self.create_parser()
        if parser != None:
            child = Popen(["curl", "-XGET", self.es_url, "-d", parser.get_search_dsl(self.query_field)], stdout=PIPE)
            return child.communicate(None)[0]
        else:
            return None

class CybertronSearcher(Searcher):
    
    def __init__(self, es_url, query_field, task):
        Searcher.__init__(self, es_url, query_field, task)
    
    def create_parser(self):
        parser = CrashParser(self.task)
        if parser.parse():
            log_info("Task %d: Use CrashParser" %(self.task.get_taskid()))
            return parser
        # Add other parser here
        return None
 
if __name__ == "__main__":
    cmdline_parser = ArgumentParser(description="Execute a retrace parser job")
    cmdline_parser.add_argument("task_id", type=int, help="Task ID (%s/<task_id>) must exist" % CONFIG["SaveDir"])
    cmdline_parser.add_argument("--foreground", action="store_true", default=False, help="Do not fork to background")
    cmdline = cmdline_parser.parse_args()

    log = cmdline._log

    try:
        task = RetraceTask(cmdline.task_id)
    except:
        sys.stderr.write("Task '%d' does not exist\n" % cmdline.task_id)
        exit(1)

    # Search in RedHat KB
    rh_es_url = "http://cybertron.eng.vmware.com:9200/redhat_kb/kb/_search"   
    rh_query_fields = ["issue","resolution","diagnostic","rootcause"]  
    rh_searcher = CybertronSearcher(rh_es_url, rh_query_fields, task)  
  
    #print rh_searcher.get_search_result()
    task.set_rhkb_matched(rh_searcher.get_search_result()) 
    
    # Search in VM Bugzilla
    vmb_es_url = "http://cybertron.eng.vmware.com:9200/bugzilla/text/_search"     
    vmb_query_fields = ["summary","text"]   
    vmb_searcher = CybertronSearcher(vmb_es_url, vmb_query_fields, task)  
    
    #print vmb_searcher.get_search_result()
    task.set_vmbugzilla_matched(vmb_searcher.get_search_result())
    
    task.set_parser_log(log.getvalue())
